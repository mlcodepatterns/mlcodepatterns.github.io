<link rel="stylesheet" href="../../../../default.css">
<script src="../../../../highlight.pack.js"></script> 
<script>hljs.initHighlightingOnLoad();</script>
<html><h3></h3><h3>Before Change</h3><pre><code class='java'>
	if prefix == &quotr&quot or prefix == &quot&quot:
		prefix = &quotr2&quot
	else:
		prefix = <a id="change">&quotr{}&quot</a>,format(int(prefix[1:]) + 1)

	dim = parse_utils.parse_dim(log)
	size_coef = parse_utils.parse_size_coef(log)
	depth = parse_utils.parse_depth(log)

	ihm_C = parse_utils.parse_ihm_C(log)
	decomp_C = parse_utils.parse_decomp_C(log)
	los_C = parse_utils.parse_los_C(log)
	pheno_C = parse_utils.parse_pheno_C(log)

	dropout = parse_utils.parse_dropout(log)
	partition = parse_utils.parse_partition(log)
	deep_supervision = parse_utils.parse_deep_supervision(log)
	target_repl_coef = parse_utils.parse_target_repl_coef(log)
	
	command = "python -u keras_main.py --network {} --prefix {} --dim {}"\
			  " --depth {} --epochs 60 --batch_size 8 --timestep 1.0"\
			  " --load_state {}".format(network, prefix, dim, depth,  last_state)

	if network.find(&quotchannel&quot) != -1:
		command += &quot --size_coef {}&quot.format(size_coef)

	if ihm_C:
		command += &quot --ihm_C {}&quot.format(ihm_C)

	if decomp_C:
		command += &quot --decomp_C {}&quot.format(decomp_C)

	if los_C:
		command += &quot --los_C {}&quot.format(los_C)

	if pheno_C:
		command += &quot --pheno_C {}&quot.format(pheno_C)

	if dropout &gt; 0.0:
		command += &quot --dropout {}&quot.format(dropout)

	if partition:
		command += &quot --partition {}&quot.format(partition)

	if deep_supervision:
		command += &quot --deep_supervision&quot

	if (target_repl_coef is not None) and target_repl_coef &gt; 0.0:
		command += &quot --target_repl_coef {}&quot.format(target_repl_coef)

	<a id="change">return command</a>

&#47&#47 TODO: mark in the file that the file is reruned already

def main():</code></pre><h3>After Change</h3><pre><code class='java'>
        print("Last state is not parsed: {}".format(filename))
        return None

    <a id="change">n_epochs = parse_utils.get_epoch(last_state)</a>

    if verbose:
        print("\tlast state = {}".format(last_state))

    network = parse_utils.parse_network(log)

    prefix = parse_utils.parse_prefix(log)
    if prefix == &quotr&quot or prefix == &quot&quot:
        prefix = &quotr2&quot
    else:
        prefix = &quotr{}&quot.format(int(prefix[1:]) + 1)

    dim = parse_utils.parse_dim(log)
    size_coef = parse_utils.parse_size_coef(log)
    depth = parse_utils.parse_depth(log)

    ihm_C = parse_utils.parse_ihm_C(log)
    decomp_C = parse_utils.parse_decomp_C(log)
    los_C = parse_utils.parse_los_C(log)
    pheno_C = parse_utils.parse_pheno_C(log)

    dropout = parse_utils.parse_dropout(log)
    partition = parse_utils.parse_partition(log)
    deep_supervision = parse_utils.parse_deep_supervision(log)
    target_repl_coef = parse_utils.parse_target_repl_coef(log)

    command = "python -u keras_main.py --network {} --prefix {} --dim {}"\
              " --depth {} --epochs 60 --batch_size 8 --timestep 1.0"\
              " --load_state {}".format(network, prefix, dim, depth,  last_state)

    if network.find(&quotchannel&quot) != -1:
        command += &quot --size_coef {}&quot.format(size_coef)

    if ihm_C:
        command += &quot --ihm_C {}&quot.format(ihm_C)

    if decomp_C:
        command += &quot --decomp_C {}&quot.format(decomp_C)

    if los_C:
        command += &quot --los_C {}&quot.format(los_C)

    if pheno_C:
        command += &quot --pheno_C {}&quot.format(pheno_C)

    if dropout &gt; 0.0:
        command += &quot --dropout {}&quot.format(dropout)

    if partition:
        command += &quot --partition {}&quot.format(partition)

    if deep_supervision:
        command += &quot --deep_supervision&quot

    if (target_repl_coef is not None) and target_repl_coef &gt; 0.0:
        command += &quot --target_repl_coef {}&quot.format(target_repl_coef)

    <a id="change">return {"command": command,
            "val_metric": last_val,
            "n_epochs": n_epochs}</a>


&#47&#47 TODO: mark in the file that the file is reruned already
def main():</code></pre>