<link rel="stylesheet" href="../../../../default.css">
<script src="../../../../highlight.pack.js"></script> 
<script>hljs.initHighlightingOnLoad();</script>
<html><h3></h3><h3>Before Change</h3><pre><code class='java'>
    from dipy.direction import ProbabilisticDirectionGetter, BootDirectionGetter, ClosestPeakDirectionGetter, DeterministicMaximumDirectionGetter

    if waymask:
        waymask_img = <a id="change">nib.load(waymask)</a>
        <a id="change">waymask_data = waymask_img.get_fdata().astype(&quotbool&quot)</a>

    &#47&#47 Commence Ensemble Tractography
    parcel_vec = list(np.ones(len(parcels)).astype(&quotbool&quot))
    streamlines = nib.streamlines.array_sequence.ArraySequence()</code></pre><h3>After Change</h3><pre><code class='java'>
    from dipy.direction import ProbabilisticDirectionGetter, BootDirectionGetter, ClosestPeakDirectionGetter, DeterministicMaximumDirectionGetter

    if waymask:
        waymask_data = <a id="change">nib</a>.load(waymask).get_fdata().astype(&quotbool&quot)

    &#47&#47 Commence Ensemble Tractography
    parcel_vec = list(np.ones(len(parcels)).astype(&quotbool&quot))
    streamlines = nib.streamlines.array_sequence.ArraySequence()
    ix = 0
    circuit_ix = 0
    stream_counter = 0
    while int(stream_counter) &lt; int(target_samples):
        for curv_thr in curv_thr_list:
            print("%s%s" % (&quotCurvature: &quot, curv_thr))

            &#47&#47 Instantiate DirectionGetter
            if directget == &quotprob&quot:
                dg = ProbabilisticDirectionGetter.from_shcoeff(mod_fit, max_angle=float(curv_thr), sphere=sphere)
            elif directget == &quotboot&quot:
                dg = BootDirectionGetter.from_data(dwi_data, mod_fit, max_angle=float(curv_thr), sphere=sphere)
            elif directget == &quotclos&quot:
                dg = ClosestPeakDirectionGetter.from_shcoeff(mod_fit, max_angle=float(curv_thr), sphere=sphere)
            elif directget == &quotdet&quot:
                dg = DeterministicMaximumDirectionGetter.from_shcoeff(mod_fit, max_angle=float(curv_thr), sphere=sphere)
            else:
                raise ValueError(&quotERROR: No valid direction getter(s) specified.&quot)

            for step in step_list:
                print("%s%s" % (&quotStep: &quot, step))

                &#47&#47 Perform wm-gm interface seeding, using n_seeds at a time
                seeds = utils.random_seeds_from_mask(atlas_data_wm_gm_int &gt; 0, seeds_count=n_seeds_per_iter,
                                                     seed_count_per_voxel=False, affine=np.eye(4))
                if len(seeds) == 0:
                    raise RuntimeWarning(&quotWarning: No valid seed points found in wm-gm interface...&quot)

                print(seeds)

                &#47&#47 Perform tracking
                if track_type == &quotlocal&quot:
                    streamline_generator = LocalTracking(dg, tiss_classifier, seeds, np.eye(4),
                                                         max_cross=int(maxcrossing), maxlen=int(max_length),
                                                         step_size=float(step), return_all=True)
                elif track_type == &quotparticle&quot:
                    streamline_generator = ParticleFilteringTracking(dg, tiss_classifier, seeds, np.eye(4),
                                                                     max_cross=int(maxcrossing),
                                                                     step_size=float(step),
                                                                     maxlen=int(max_length),
                                                                     pft_back_tracking_dist=pft_back_tracking_dist,
                                                                     pft_front_tracking_dist=pft_front_tracking_dist,
                                                                     particle_count=particle_count, return_all=True)
                else:
                    raise ValueError(&quotERROR: No valid tracking method(s) specified.&quot)

                &#47&#47 Filter resulting streamlines by roi-intersection characteristics
                roi_proximal_streamlines = Streamlines(select_by_rois(streamline_generator, affine=np.eye(4),
                                                                      rois=parcels, include=parcel_vec,
                                                                      mode=&quotany&quot,
                                                                      tol=roi_neighborhood_tol))

                print("%s%s" % (&quotQualifying Streamlines by node intersection: &quot, len(roi_proximal_streamlines)))

                roi_proximal_streamlines = nib.streamlines.array_sequence.ArraySequence([s for s in
                                                                                         roi_proximal_streamlines if
                                                                                         len(s) &gt; float(min_length)])

                print("%s%s" % (&quotQualifying Streamlines by minimum length criterion: &quot, len(roi_proximal_streamlines)))

                if waymask:
                    roi_proximal_streamlines = roi_proximal_streamlines[utils.near_roi(roi_proximal_streamlines,
                                                                                       np.eye(4),
                                                                                       waymask_data,
                                                                                       tol=roi_neighborhood_tol,
                                                                                       mode=&quotany&quot)]
                    print("%s%s" % (&quotQualifying Streamlines by waymask proximity: &quot, len(roi_proximal_streamlines)))

                &#47&#47 Repeat process until target samples condition is met
                ix = ix + 1
                for s in roi_proximal_streamlines:
                    stream_counter = stream_counter + len(s)
                    streamlines.append(s)
                    if int(stream_counter) &gt;= int(target_samples):
                        break
                    else:
                        continue

                &#47&#47 Cleanup memory
                del dg
                del seeds
                <a id="change">del roi_proximal_streamlines</a>
                del streamline_generator

        circuit_ix = circuit_ix + 1
        print("%s%s%s%s%s" % (&quotCompleted hyperparameter circuit: &quot, circuit_ix, &quot...\nCumulative Streamline Count: &quot,
                              Fore.CYAN, stream_counter))
        print(Style.RESET_ALL)

    print(&quot\n&quot)

    &#47&#47 Final cleanup
    <a id="change">del waymask_data</a>
    del stream_counter
    del parcel_vec
    del parcels
</code></pre>