<link rel="stylesheet" href="../../../../default.css">
<script src="../../../../highlight.pack.js"></script> 
<script>hljs.initHighlightingOnLoad();</script>
<html><h3></h3><h3>Before Change</h3><pre><code class='java'>
    table_size = table.size()
    return table.lookup(y), table_size

  <a id="change">with tf.name_scope(name, &quotapply_vocab&quot):
    lookup_fn = lookup_fn or _apply_vocab

    result, table_size = api.apply_function(
        lookup_fn, x, deferred_vocab_filename_tensor)

    &#47&#47 Specify schema overrides which will override the values in the schema
    &#47&#47 with the min and max values, which are deferred as they are only known
    &#47&#47 once the analyzer has run.
    &#47&#47
    &#47&#47 `table_size` includes the num oov buckets.  The default value is only used
    &#47&#47 if num_oov_buckets &gt; 0.
    min_value = tf.constant(0, tf.int64)
    max_value = table_size - 1
    if num_oov_buckets &lt;= 0:
      min_value = tf.minimum(min_value, default_value)
      max_value = tf.maximum(max_value, default_value)
    api.set_tensor_schema_overrides(result, min_value, max_value)

    return result


</a>def segment_indices(segment_ids, name=None):
  Returns a `Tensor` of indices within each segment.

  segment_ids should be a sequence of non-decreasing non-negative integers that</code></pre><h3>After Change</h3><pre><code class='java'>
                lookup_fn=None,
                name=None):
  rSee `tft.apply_vocabulary`.
  <a id="change">return apply_vocabulary(
      x=x,
      deferred_vocab_filename_tensor=deferred_vocab_filename_tensor,
      default_value=default_value,
      num_oov_buckets=num_oov_buckets,
      lookup_fn=lookup_fn,
      name=name)</a>


def segment_indices(segment_ids, name=None):
  Returns a `Tensor` of indices within each segment.</code></pre>