<link rel="stylesheet" href="../../../../default.css">
<script src="../../../../highlight.pack.js"></script> 
<script>hljs.initHighlightingOnLoad();</script>
<html><h3></h3><h3>Before Change</h3><pre><code class='java'>

    
    _check_unknown_options(unknown_options)
    <a id="change">if jac is not None:
        warnings.warn("DF-SANE solver does not use a Jacobian", category=OptimizeWarning)

   </a> nexp = 2

    if eta_strategy is None:
        &#47&#47 Different choice from [1], as their eta is not invariant</code></pre><h3>After Change</h3><pre><code class='java'>
    
    _check_unknown_options(unknown_options)

    <a id="change">if line_search not in (&quotcheng&quot, &quotcruz&quot):
        raise ValueError("Invalid value %r for &quotline_search&quot" % (line_search,))

   </a> nexp = 2

    if eta_strategy is None:
        &#47&#47 Different choice from [1], as their eta is not invariant
        &#47&#47 vs. scaling of F.
        def eta_strategy(k, x, F):
            &#47&#47 Obtain squared 2-norm of the initial residual from the outer scope
            return f_0 / (1 + k)**2

    if fnorm is None:
        def fnorm(F):
            &#47&#47 Obtain squared 2-norm of the current residual from the outer scope
            return f_k**(1.0/nexp)

    def fmerit(F):
        return np.linalg.norm(F)**nexp

    nfev = [0]
    f, x_k, x_shape, f_k, F_k, is_complex = _wrap_func(func, x0, fmerit, nfev, maxfev, args)

    k = 0
    f_0 = f_k
    sigma_k = sigma_0

    F_0_norm = fnorm(F_k)

    &#47&#47 For the &quotcruz&quot line search
    prev_fs = collections.deque([f_k], M)

    &#47&#47 For the &quotcheng&quot line search
    <a id="change">Q = 1.0</a>
    <a id="change">C = f_0</a>

    converged = False
    message = "too many function evaluations required"
</code></pre>