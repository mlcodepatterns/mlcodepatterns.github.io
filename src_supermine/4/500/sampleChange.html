<link rel="stylesheet" href="../../../../default.css">
<script src="../../../../highlight.pack.js"></script> 
<script>hljs.initHighlightingOnLoad();</script>
<html><h3></h3><h3>Before Change</h3><pre><code class='java'>
                break
            image_sizes = {
                name: data[name].shape for name in self.window.fields}
            import pdb; <a id="change">pdb.set_trace()</a>
            coordinates = rand_spatial_coordinates(
                image_id, image_sizes,
                self.window.shapes, self.window.n_samples)
            &#47&#47  initialise output dict</code></pre><h3>After Change</h3><pre><code class='java'>
            static_window_shapes = self.window.match_image_shapes(image_shapes)
            coordinates = grid_spatial_coordinates(
                image_id, image_shapes, static_window_shapes, self.border_size)
            <a id="change">n_locations = coordinates.values()[0].shape[0]</a>
            <a id="change">for i in range(n_locations):
                &#47&#47  initialise output dict
                output_dict = {}
                for name in list(data):
                    assert coordinates[name].shape[0] == n_locations, \
                        "different number of grid samples from the input" \
                        "images, don&quott know how to combine them in the queue"
                    x_, y_, z_, _x, _y, _z = coordinates[name][i, 1:]
                    try:
                        image_window = data[name][x_:_x, y_:_y, z_:_z, ...]
                    except ValueError:
                        tf.logging.fatal(
                            "dimensionality miss match in input volumes, "
                            "please specify spatial_window_size with a "
                            "3D tuple and make sure each element is "
                            "smaller than the image length in each dim.")
                        raise
                    &#47&#47 fill output dict with data
                    coordinates_key = self.window.coordinates_placeholder(name)
                    image_data_key = self.window.image_data_placeholder(name)
                    output_dict[coordinates_key] = coordinates[name][[i], ...]
                    output_dict[image_data_key] = image_window[np.newaxis, ...]
                yield output_dict


</a>def grid_spatial_coordinates(subject_id, img_sizes, win_sizes, border_size):
    
    This function generates all coordinates of feasible windows, with
    step sizes specified in grid_size parameter</code></pre>